#### 什么是浏览器缓存


#### 本地存储cookie、sessionStorage、localStorage之间的区别
1.共同点：都是保存在浏览器端，且同源的；
2.区别：cookie数据始终在同源的http请求中携带（即使不需要）；cookie数据有域（domain）和路径（path）的概念，可以设置cookie的域在一级域名不同二级域名相同的域之间共享cookie数据，也可以限制cookie只属于某个路径；cookie数据不能超过4K；每个域名包含cookie数限制为30-50个不等；
3.区别：sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存；存储大小均可达到5M或更大；
4.区别：sessionStorage：仅在当前浏览器窗口关闭前有效，`特别注意：sessionStorage仅在同窗口(tab)同域下共享，同一个页面在不同的tab里耶无法共享`；localStorage：始终有效，除非手动清除，`localStorage在所有同源窗口中都是共享的`；

#### web安全总结

- CSRF攻击原理图：
![enter image description here](http://pic002.cnblogs.com/img/hyddd/200904/2009040916453171.jpg)
防御方式：操作数据的表单中添加随机（不可预测）的token。

#### 栅格布局原理


#### 原形链和闭包
1.JS引擎执行环境（`全局代码上下文`）准备工作：
| 变量	   | 提升表现 |
| -------- | :-----: |
| 变量、函数表达式  | 声明（默认赋值：undefined）      |
| 函数声明 | 赋值（`变量名和函数名重复时，函数会覆盖变量`）      |
| this | 赋值 |
2.JS引擎执行环境（`函数体上下文`）准备工作：
| 变量 | 提升表现 |
| -------- | :-----: |
| 参数 | 赋值 |
| arguments | 赋值 |
| 自由变量的取值作用域 | 赋值（`函数在定义的时候，就已经确定了函数体内部自由变量的作用域`） |
`PS：自有变量即在A作用域中使用变量X，却并没有在A作用域中声明，对于A作用域来说，X就是一个自有变量。自由变量的取值——要到创建这个函数的作用域中取值，是创建而不是调用，这就是所谓的"静态作用域"，如果跨了一步没有找到——接着跨——一直跨到全局作用域为止，如果全局作用域也没有，那就是未定义。`

3.执行上下文环境：在执行代码之前，把将要用到的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空。（`函数每执行一次都会产生一个新的上下文环境`）
4.函数中this的取值，是在函数真正调用执行的时候确定的，函数定义的时候确定不了（`这里除了ES6中的箭头函数`）。
- 函数作为构造函数用，其中的this代表即将new出来的对象；
- 函数正常调用时，其中的this为函数的调用者（`大部分情况下全局的函数调用都省略了window.`）；
```  javascript
	function fn () {
	}
	fn();// 这里其实应该是window.fn()，只不过window.可省略
	
	var obj = {
		x: 10,
		y: function () {
			console.log(this);
			console.log(this.x)''
		}
	}
	obj.y();// 此时函数中的this为obj
	var y = obj.y;
	y();// 此时函数中的this为window，因为y是全局变量，所以可以省略window.
```
- 函数使用call、apply、bind调用会修改上下文对象；
- 箭头函数中的this为定义时的上下文对象；
- `PS：如果函数调用时找不到所属关系，即该函数属于哪个对象，那么函数内部this就是window`
``` javascript
	var obj = {
		x: function () {
			function fn () {
				console.log(this);
			}
			fn();
		}
	}
	obj.x();// 打印结果为window，因为fn找不到所属关系，所以内部this为window
```
5.JS除了全局作用域之外，只有函数可以创建作用域；作用域是在函数定义时就已经确定了，而不是在函数调用时确定。作用域有上下级关系，上下级关系的确定就看函数是在哪个作用域下创建的；作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突；
![Alt text](./1511837344223.png)


#### 异步原理
1.event-loop——事件轮询




#### XMLHttpRequest
1.Ajax和XMLHttpRequest的关系：我们使用XMLHttpRequest对象来发送一个Ajax请求
2.发展历程：其标准分为两个阶段

`XMLHttpRequest Level 1`存在以下缺点：
- 受同源策略的限制，不能发送跨域请求
- 不能发送二进制文件(如图片、音频、视频等)
- 发送和获取数据的过程中，无法实时获取进度信息，只能判断是否完成

`XMLHttpRequest Level 2`增加了以下功能：
- 在服务器端允许的情况下，可以发送跨域请求
- 支持发送和接收二进制数据
- 新增formData对象，支持发送表单数据
- 发送和获取数据时，可以获取进度信息
- 可以设置请求的超时时间

3.XMLHttpRequest兼容性
![Alt text](./1513668406246.png)
4.


